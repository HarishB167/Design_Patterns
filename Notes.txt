
- What are Design Patterns
* Elegant solution to repeating problems

- Categories
* Creational, Structural, Behavioural
* Creational : Different ways to create objects
* Structural : Relationships b/w these objects
* Behavioural : Interaction/Communication b/w objects (Here in first part)

--------------------------------------
Section 2 : Essentials

- Coupling
* Dependency on another class
* Consumer class also recompiled on change.

- Interfaces
* Contract - class capabilities
* Prevents recompilation of dependent classes.
* public interface MyInteface { float calculateTax();}
* public class MyClass implements MyInterface {}
* Using dependency injection framework.

- Encapsulation
* Restrict state/data changes externally directly.
* Provide getters/setters.

- Abstraction
* Hide unecessary details
* Using private for non-consumer methods.

- Inheritance
* Extends keyword

- Polymorphism
* Object's ability to morph
* Using abstract method and class

- UML
* Unified Modeling Lang
* -/+ = private/public
* Method <-/+> <name>([args,..])[:<returnType>]
* Field <-/+> <name>:type
* Relationship
Inheritance (filled triangle arrow) (arrow points to super class),
Composition (Arrow at one side (size) and diamond at other(shape))
shape is composed of size, 
Dependency (parameter/local var) (dashed arrow pointing to used class)

--------------------------------------
Section 3 : Memento Pattern

- Undo Mechanism implement

- Structure
* Editor (Originator)
createState
restore(state)
* EditorState (Memento)
* History (Caretaker)
List of EditorState
push(state), pop
* Relationship
Depend(Editor, EditorState)
Compose(History, EditorState)

--------------------------------------
Section 4 : State Pattern

- Tool based canvas state

- Structure
* Canvas (Context)
currentTool
action() (request)
* Tool (Abstract) (State)
action() (handle)
* Tool1, Tool2 (ConcreteStateA,B)
action() (handle)
* Relationship
Compose(Canvas, Tool)
Inheritance(Tool1, Tool)

- Open Closed Principle
* open for extension and closed for modification

- Makes Extensible

- Doing different things based on state

--------------------------------------
Section 5 : Iterator Pattern

- Browsing History

- Structure
* BrowseHistory
push, pop, createIterator
* Iterator (interface)
next, current, isDone
* Iterator1, Iterator2
Created inside BrowseHistory
* Relationship
Depend(BrowseHistory, Iterator)
Inheritance(Iterator1, Iterator)

--------------------------------------
Section 6 - Strategy Pattern

- Storing Images with compression and filter

- Structure
* ImageStorage (Context)
compressor, filter
store()
* Compressor, Filter (interface) (Strategy)
compress(), apply()
* JpegComp, PngComp, B&WFil, HighContFil (ConcreteStrategyA,B)
compress(), apply()
* Relationship
Compose(ImageStorage, [Compressor, Filter])
Inheritance([JpegComp, PngComp], Compressor)
Inheritance([B&WFil, HighContFil], Filter)

- Doing same thing differently

--------------------------------------
Section 7 - Template method Pattern

- Logging each task in banking

- Structure
* Task (AbstractClass)
execute (templateMethod)
doExecute (primitiveOperation) <Hooks>
* TransferMoney, GenerateReport (ConcreteClass)
doExecute (primitiveOperation)
* Relationship
Inheritance(TransferMoney, Task)

--------------------------------------
Status - Section 5 completed
